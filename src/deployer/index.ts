/**
 * Deployer Module - Publishes to GitHub and deploys to Render
 */
import { execa } from 'execa';
import fs from 'fs-extra';
import path from 'path';
import { logger } from '../utils/logger.js';

export interface DeployResult {
  success: boolean;
  githubUrl?: string;
  renderUrls?: {
    web?: string;
    api?: string;
    dashboard?: string;
  };
  errors: string[];
}

export class DeployerModule {
  private githubOwner: string;
  private renderApiKey?: string;

  constructor(githubOwner: string, renderApiKey?: string) {
    this.githubOwner = githubOwner;
    this.renderApiKey = renderApiKey;
  }

  async deploy(projectDir: string, repoName: string): Promise<DeployResult> {
    const result: DeployResult = {
      success: false,
      errors: [],
    };

    try {
      // 1. Initialize git repository
      logger.info('Initializing git repository...');
      await this.initGitRepo(projectDir, repoName);

      // 2. Create GitHub repository
      logger.info('Creating GitHub repository...');
      const githubUrl = await this.createGitHubRepo(projectDir, repoName);
      result.githubUrl = githubUrl;

      // 3. Push code
      logger.info('Pushing code to GitHub...');
      await this.pushToGitHub(projectDir);

      // 4. Deploy to Render (if API key provided)
      if (this.renderApiKey) {
        logger.info('Deploying to Render...');
        result.renderUrls = await this.deployToRender(projectDir, repoName);
      } else {
        logger.info('Render API key not provided, skipping deployment');
        result.renderUrls = {
          dashboard: 'https://dashboard.render.com/blueprints',
        };
      }

      result.success = true;
      logger.info('Deployment complete!');

    } catch (e: any) {
      result.errors.push(e.message);
      logger.error(`Deployment failed: ${e.message}`);
    }

    return result;
  }

  private async initGitRepo(projectDir: string, repoName: string): Promise<void> {
    const gitDir = path.join(projectDir, '.git');
    
    if (await fs.pathExists(gitDir)) {
      await fs.remove(gitDir);
    }

    await execa('git', ['init'], { cwd: projectDir });
    await execa('git', ['branch', '-m', 'master', 'main'], { cwd: projectDir }).catch(() => {});
    await execa('git', ['add', '-A'], { cwd: projectDir });
    await execa('git', ['commit', '-m', `Initial commit - ${repoName}\n\nGenerated by AppLabs2`], { 
      cwd: projectDir,
      env: {
        GIT_AUTHOR_NAME: 'AppLabs2',
        GIT_AUTHOR_EMAIL: 'applabs2@bot.local',
        GIT_COMMITTER_NAME: 'AppLabs2',
        GIT_COMMITTER_EMAIL: 'applabs2@bot.local',
      }
    });
  }

  private async createGitHubRepo(projectDir: string, repoName: string): Promise<string> {
    // Check if repo exists
    try {
      await execa('gh', ['repo', 'view', `${this.githubOwner}/${repoName}`]);
      logger.info(`Repository ${repoName} already exists, using it`);
    } catch {
      // Create new repo
      await execa('gh', [
        'repo', 'create', repoName,
        '--public',
        '--source=.',
        '--remote=origin'
      ], { cwd: projectDir });
    }

    return `https://github.com/${this.githubOwner}/${repoName}`;
  }

  private async pushToGitHub(projectDir: string): Promise<void> {
    try {
      await execa('git', ['push', '-u', 'origin', 'main', '--force'], { cwd: projectDir });
    } catch (e) {
      // Try setting remote if not exists
      const repoUrl = (await execa('gh', ['repo', 'view', '--json', 'url', '-q', '.url'], { cwd: projectDir })).stdout;
      await execa('git', ['remote', 'add', 'origin', repoUrl], { cwd: projectDir }).catch(() => {});
      await execa('git', ['push', '-u', 'origin', 'main', '--force'], { cwd: projectDir });
    }
  }

  private async deployToRender(projectDir: string, repoName: string): Promise<{ web?: string; api?: string; dashboard?: string }> {
    const slug = repoName.toLowerCase().replace(/[^a-z0-9]/g, '-');
    const renderYaml = path.join(projectDir, 'render.yaml');
    
    if (!await fs.pathExists(renderYaml)) {
      return { dashboard: 'https://dashboard.render.com/blueprints' };
    }

    const headers = {
      'Authorization': `Bearer ${this.renderApiKey}`,
      'Content-Type': 'application/json',
    };

    // Get owner ID
    const ownerRes = await fetch('https://api.render.com/v1/owners', { headers });
    const owners = await ownerRes.json() as any[];
    const ownerId = owners[0]?.owner?.id;

    if (!ownerId) {
      throw new Error('Could not get Render owner ID');
    }

    // Create database
    logger.info('Creating Render database...');
    const dbRes = await fetch('https://api.render.com/v1/postgres', {
      method: 'POST',
      headers,
      body: JSON.stringify({
        ownerId,
        name: `${slug}-db`,
        databaseName: slug.replace(/-/g, '_'),
        plan: 'free',
        region: 'oregon',
        version: '16',
      }),
    });
    const dbData = await dbRes.json() as any;
    const dbId = dbData.id;

    // Wait for database
    await new Promise(resolve => setTimeout(resolve, 5000));

    // Get connection string
    const connRes = await fetch(`https://api.render.com/v1/postgres/${dbId}/connection-info`, { headers });
    const connData = await connRes.json() as any;
    const dbUrl = connData.internalConnectionString;

    // Create API service
    logger.info('Creating Render API service...');
    const apiRes = await fetch('https://api.render.com/v1/services', {
      method: 'POST',
      headers,
      body: JSON.stringify({
        type: 'web_service',
        autoDeploy: 'yes',
        repo: `https://github.com/${this.githubOwner}/${repoName}`,
        branch: 'main',
        name: `${slug}-api`,
        ownerId,
        serviceDetails: {
          region: 'oregon',
          plan: 'free',
          env: 'node',
          envSpecificDetails: {
            buildCommand: 'npm install -g pnpm && pnpm install && cd apps/api && npx prisma generate && pnpm build',
            startCommand: 'cd apps/api && node dist/index.js',
          },
          envVars: [
            { key: 'DATABASE_URL', value: dbUrl },
            { key: 'DEMO_MODE', value: 'true' },
          ],
        },
      }),
    });
    const apiData = await apiRes.json() as any;
    const apiUrl = apiData.service?.serviceDetails?.url;

    // Create Web service
    logger.info('Creating Render web service...');
    const webRes = await fetch('https://api.render.com/v1/services', {
      method: 'POST',
      headers,
      body: JSON.stringify({
        type: 'web_service',
        autoDeploy: 'yes',
        repo: `https://github.com/${this.githubOwner}/${repoName}`,
        branch: 'main',
        name: `${slug}-web`,
        ownerId,
        serviceDetails: {
          region: 'oregon',
          plan: 'free',
          env: 'node',
          envSpecificDetails: {
            buildCommand: 'npm install -g pnpm && pnpm install && cd apps/web && pnpm build',
            startCommand: 'cd apps/web && pnpm start',
          },
          envVars: [
            { key: 'NEXT_PUBLIC_API_URL', value: apiUrl || `https://${slug}-api.onrender.com` },
            { key: 'NEXTAUTH_URL', value: `https://${slug}-web.onrender.com` },
            { key: 'NEXTAUTH_SECRET', generateValue: true },
          ],
        },
      }),
    });
    const webData = await webRes.json() as any;
    const webUrl = webData.service?.serviceDetails?.url;

    return {
      web: webUrl || `https://${slug}-web.onrender.com`,
      api: apiUrl || `https://${slug}-api.onrender.com`,
      dashboard: 'https://dashboard.render.com',
    };
  }
}
